From: http://code.google.com/p/andrei-development/downloads/detail?name=eGalax_patch_for_XBMC_12.tar.gz

--- a/xbmc/input/MouseStat.h     2013-01-29 16:20:27.000000000 +0200
+++ b/xbmc/input/MouseStat.h	2013-02-24 10:47:27.570767079 +0200
@@ -123,7 +123,7 @@
      */
     BUTTON_ACTION Update(unsigned int time, int x, int y, bool down);
   private:
-    static const unsigned int click_confines = 5;        ///< number of pixels that the pointer may move while the button is down to trigger a click
+    static const unsigned int click_confines = 7;        ///< number of pixels that the pointer may move while the button is down to trigger a click
     static const unsigned int short_click_time = 1000;   ///< time for mouse down/up to trigger a short click rather than a long click
     static const unsigned int double_click_time = 500;   ///< time for mouse down following a short click to trigger a double click

--- a/xbmc/input/linux/LinuxInputDevices.cpp	2013-01-29 16:20:27.000000000 +0200
+++ b/xbmc/input/linux/LinuxInputDevices.cpp	2013-02-24 11:29:57.655929879 +0200
@@ -317,6 +317,13 @@
 
 static char remoteStatus = 0xFF; // paired, battery OK
 
+/* [touchscreens] calibration values */
+static int calib_x_d = 1280;
+static float calib_x_fact = -1.0f;
+static int calib_y_d = 720;
+static float calib_y_fact = -1.0f;
+static int swap_axes = 0;
+
 CLinuxInputDevice::CLinuxInputDevice(const std::string fileName, int index)
 {
   m_fd = -1;
@@ -502,6 +509,13 @@
 {
   int code = levt.code;
 
+  /* [touchscreens] when PRESS or RELEASE action occurs 
+  if(levt.code == BTN_TOUCH)
+  {
+    m_mouseX = g_graphicsContext.GetWidth() + 1;
+    m_mouseY = g_graphicsContext.GetHeight() + 1;
+  } */
+
   /* map touchscreen and smartpad events to button mouse */
   if (code == BTN_TOUCH || code == BTN_TOOL_FINGER)
     code = BTN_MOUSE;
@@ -645,11 +659,17 @@
   switch (levt.code)
   {
   case ABS_X:
-    m_mouseX = levt.value;
+    if(swap_axes)
+      m_mouseY = g_graphicsContext.GetHeight() - (int)(((float)levt.value) * (calib_y_fact)) - calib_y_d;
+    else
+      m_mouseX = g_graphicsContext.GetWidth() - (int)(((float)levt.value) * (calib_x_fact)) - calib_x_d;
     break;
 
   case ABS_Y:
-    m_mouseY = levt.value;
+    if(swap_axes)
+      m_mouseX = g_graphicsContext.GetWidth() - (int)(((float)levt.value) * (calib_x_fact)) - calib_x_d;
+    else
+      m_mouseY = g_graphicsContext.GetHeight() - (int)(((float)levt.value) * (calib_y_fact)) - calib_y_d;
     break;
   
   case ABS_MISC:
@@ -840,6 +860,8 @@
   unsigned long evbit[NBITS(EV_CNT)];
   unsigned long keybit[NBITS(KEY_CNT)];
 
+  FILE *c_fp = NULL;
+
   /* get device name */
   bzero(m_deviceName, sizeof(m_deviceName));
   ioctl(fd, EVIOCGNAME(sizeof(m_deviceName)-1), m_deviceName);
@@ -854,6 +876,25 @@
   }
   CLog::Log(LOGINFO, "opened device '%s' (file name %s), m_bSkipNonKeyEvents %d\n", m_deviceName, m_fileName.c_str(), m_bSkipNonKeyEvents);
 
+  /* [touchscreens] read calibration values(this should be changed to an XML file) */
+  if(strstr(m_deviceName, "eGalax") || strstr(m_deviceName, "Touch") || strstr(m_deviceName, "Acer T230H"))
+  {
+      c_fp = fopen("/usr/share/eGalaxCalibration/touchscreen_axes_calib", "r");
+      if (c_fp)
+      {
+        fscanf(c_fp, "calib_x_d=%d;calib_x_fact=%f;calib_y_d=%d;calib_y_fact=%f;swap_axes=%d;\n",
+            &calib_x_d,
+            &calib_x_fact,
+            &calib_y_d,
+            &calib_y_fact,
+            &swap_axes
+        );
+
+        /* close the file */
+        fclose(c_fp);
+      }
+  }
+  
   /* get event type bits */
   ioctl(fd, EVIOCGBIT(0, sizeof(evbit)), evbit);
